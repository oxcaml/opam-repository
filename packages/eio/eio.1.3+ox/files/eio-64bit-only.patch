From e6823784545a453af81493f744ddb2e73b8ea10a Mon Sep 17 00:00:00 2001
From: Anil Madhavapeddy <anil@recoil.org>
Date: Fri, 22 Aug 2025 17:56:19 +0200
Subject: [PATCH] Fix build on OxCaml, which doesn't support 32-bit
 architectures

This is just a quick fix, but I do wonder if Eio should just go
64-bit only now too. I haven't used a 32-bit platform in some time,
with the possible exception of js_of_ocaml
---
 lib_eio/core/cells.ml          | 18 +-----------------
 lib_eio/core/cells_int63.ml.32 | 12 ++++++++++++
 lib_eio/core/cells_int63.ml.64 | 14 ++++++++++++++
 lib_eio/core/dune              | 10 ++++++++++
 4 files changed, 37 insertions(+), 17 deletions(-)
 create mode 100644 lib_eio/core/cells_int63.ml.32
 create mode 100644 lib_eio/core/cells_int63.ml.64

diff --git a/lib_eio/core/cells.ml b/lib_eio/core/cells.ml
index 32f9fdb87..1afd9a621 100644
--- a/lib_eio/core/cells.ml
+++ b/lib_eio/core/cells.ml
@@ -5,23 +5,7 @@ module type CELL = sig
   val dump : _ t Fmt.t
 end
 
-(* To avoid worrying about wrapping on 32-bit platforms,
-   we use 63-bit integers for indexes in all cases.
-   On 64-bit platforms, this is just [int]. *)
-module Int63 = struct
-  include Optint.Int63
-
-  (* Fallback for 32-bit platforms. *)
-  let rec fetch_and_add_fallback t delta =
-    let old = Atomic.get t in
-    if Atomic.compare_and_set t old (add old (of_int delta)) then old
-    else fetch_and_add_fallback t delta
-
-  let fetch_and_add : t Atomic.t -> int -> t =
-    match is_immediate with
-    | True -> Atomic.fetch_and_add
-    | False -> fetch_and_add_fallback
-end
+module Int63 = Cells_int63
 
 module Make(Cell : CELL) = struct
   let cells_per_segment = 1 lsl Cell.segment_order
diff --git a/lib_eio/core/cells_int63.ml.32 b/lib_eio/core/cells_int63.ml.32
new file mode 100644
index 000000000..c740d6995
--- /dev/null
+++ b/lib_eio/core/cells_int63.ml.32
@@ -0,0 +1,12 @@
+include Optint.Int63
+
+(* Fallback for 32-bit platforms. *)
+let rec fetch_and_add_fallback t delta =
+  let old = Atomic.get t in
+  if Atomic.compare_and_set t old (add old (of_int delta)) then old
+  else fetch_and_add_fallback t delta
+
+let fetch_and_add : t Atomic.t -> int -> t =
+  match is_immediate with
+  | True -> Atomic.fetch_and_add
+  | False -> fetch_and_add_fallback
diff --git a/lib_eio/core/cells_int63.ml.64 b/lib_eio/core/cells_int63.ml.64
new file mode 100644
index 000000000..095e35268
--- /dev/null
+++ b/lib_eio/core/cells_int63.ml.64
@@ -0,0 +1,14 @@
+type t = int
+
+let zero = 0
+let succ = succ
+let pred = pred
+let add = (+)
+let compare = Int.compare
+let shift_left = Int.shift_left
+let shift_right_logical = Int.shift_right_logical
+let to_int x = x
+let of_int x = x
+let pp = Format.pp_print_int
+
+let fetch_and_add = Atomic.fetch_and_add
\ No newline at end of file
diff --git a/lib_eio/core/dune b/lib_eio/core/dune
index 4bda7916d..caacff47e 100644
--- a/lib_eio/core/dune
+++ b/lib_eio/core/dune
@@ -2,3 +2,13 @@
   (name eio__core)
   (public_name eio.core)
   (libraries hmap lwt-dllist fmt optint eio.runtime_events))
+
+(rule
+ (target cells_int63.ml)
+ (enabled_if (not %{arch_sixtyfour}))
+ (action (copy cells_int63.ml.32 %{target})))
+
+(rule
+ (target cells_int63.ml)
+ (enabled_if %{arch_sixtyfour})
+ (action (copy cells_int63.ml.64 %{target})))
