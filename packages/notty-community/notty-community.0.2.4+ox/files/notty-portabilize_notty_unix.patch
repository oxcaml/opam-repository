--- a/src-unix/notty_unix.ml
+++ b/src-unix/notty_unix.ml
@@ -3,7 +3,7 @@
 
 open Notty
 
-external c_winsize : Unix.file_descr -> int = "caml_notty_winsize" [@@noalloc]
+external c_winsize : Unix.file_descr -> int  @@ portable = "caml_notty_winsize" [@@noalloc]
 external winch_number : unit -> int = "caml_notty_winch_number" [@@noalloc]
 
 let iter f = function Some x -> f x | _ -> ()
@@ -80,14 +80,34 @@
 
   module Winch = struct
 
-    let h  = Hashtbl.create 3
+    let h : (int, unit -> unit) Portable_lockfree_htbl.t =
+      Portable_lockfree_htbl.create (module Int)
+
     and id = ref 0
 
     let add fd f =
       let n = !id in
-      set_winch_handler (fun () -> Hashtbl.iter (fun _ f -> f ()) h) |> ignore;
-      Hashtbl.add h n (fun () -> winsize fd |> iter f); incr id;
-      `Revert (fun () -> Hashtbl.remove h n)
+      set_winch_handler (fun () ->
+        Portable_lockfree_htbl.to_alist h
+        |> List.iter (fun (_, f) -> f ())
+        ) |> ignore;
+      let () =
+        match
+          Portable_lockfree_htbl.add h ~key:n ~data:(fun () -> winsize fd |> iter f);
+        with
+        | Null -> ()
+        | This _ -> ()
+      in
+      incr id;
+      `Revert (fun () ->
+        let () =
+          match
+            Portable_lockfree_htbl.remove h n
+          with
+          | Null -> ()
+          | This _ -> ()
+        in
+        ())
   end
 
   module Input = struct
@@ -122,7 +142,7 @@
   ; input    : Input.t
   ; fds      : Unix.file_descr * Unix.file_descr
   ; unwinch  : (unit -> unit) Lazy.t
-  ; mutable winched : bool
+  ; mutable winched : (int * int) list [@atomic]
   }
 
   let write t =
@@ -150,10 +170,14 @@
       ; buf     = Buffer.create 4096
       ; input   = Input.create ~nosig input
       ; fds     = (input, output)
-      ; winched = false
+      ; winched = []
       ; unwinch = lazy (
-          let `Revert f = Winch.add output @@ fun dim ->
-            Buffer.reset t.buf; t.winched <- true; set_size t dim in f)
+          let winched = [%atomic.loc t.winched] in
+          let `Revert f =
+            Winch.add output @@ fun dim ->
+              Portable.Atomic.Loc.update winched ~pure_f:(fun l -> l @ [dim]);
+          in
+          f)
     } in
     winsize output |> iter (set_size t);
     (Lazy.force t.unwinch |> ignore) [@ocaml.warning "-5"];
@@ -163,12 +187,25 @@
 
   let rec event = function
     | t when Tmachine.dead t.trm -> `End
-    | t when t.winched -> t.winched <- false; `Resize (size t)
-    | t -> Unix.(try Input.event t.input with Unix_error (EINTR, _, _) -> event t)
+    | t ->
+      let winch_event = ref None in
+      let winched = [%atomic.loc t.winched] in
+      Portable.Atomic.Loc.update winched ~pure_f:(function [] -> winch_event := None; [] | hd :: tl ->
+        winch_event:= Some hd;
+        tl);
+      (match !winch_event with
+       | None ->
+          Unix.(try Input.event t.input with Unix_error (EINTR, _, _) -> event t)
+       | Some dim ->
+          Buffer.reset t.buf;
+          set_size t dim;
+          `Resize (size t)
+      )
+  ;;
 
   let pending t =
     not (Tmachine.dead t.trm) &&
-    (t.winched || Unescape.pending t.input.Input.flt)
+    (not (List.is_empty t.winched) || Unescape.pending t.input.Input.flt)
 
   let fds t = t.fds
 end
--- a/src-unix/notty_unix.mli
+++ b/src-unix/notty_unix.mli
@@ -130,7 +130,7 @@
       listeners without conflicting with the rest of the machinery. *)
   module Winch : sig
 
-    val add : Unix.file_descr -> ((int * int) -> unit) -> [`Revert of unit -> unit]
+    val add : Unix.file_descr -> ((int * int) -> unit) @ portable  -> [`Revert of unit -> unit]
     (** [add fd f] registers a [SIGWINCH] handler. Every time the signal is
         delivered, [f] is called with the current size of the tty backing [fd].
         If [fd] is not a tty, [f] is never called.
@@ -213,7 +213,7 @@
 
   val cap_for_fd        : Unix.file_descr -> Cap.t
   val setup_tcattr      : nosig:bool -> Unix.file_descr -> [ `Revert of (unit -> unit) ]
-  val set_winch_handler : (unit -> unit) -> [ `Revert of (unit -> unit) ]
+  val set_winch_handler : (unit -> unit) @ portable -> [ `Revert of (unit -> unit) ]
 
   module Gen_output (O : sig
     type fd
